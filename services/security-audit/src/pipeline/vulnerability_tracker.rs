//! Vulnerability tracker and audit report template generator.

use super::severity_classifier::Severity;
use chrono::Utc;

pub struct TrackingEntry {
    pub id: String,
    pub description: String,
    pub severity: Severity,
    pub open: bool,
}

pub struct VulnerabilityTracker {
    entries: Vec<TrackingEntry>,
}

impl VulnerabilityTracker {
    pub fn new() -> Self {
        Self {
            entries: Vec::new(),
        }
    }

    pub fn log_finding(&mut self, entry: TrackingEntry) {
        self.entries.push(entry);
    }

    /// Generates a standardized audit report
    pub fn generate_audit_report(&self) -> String {
        let date = Utc::now().to_rfc3339();
        let mut report = format!("# Security Audit Report\n\nDate: {}\n\n## Executive Summary\n\nTotal findings: {}\n\n## Findings\n\n", date, self.entries.len());
        
        for entry in &self.entries {
            let status = if entry.open { "OPEN" } else { "CLOSED" };
            report.push_str(&format!("### [{}] {} ({})\n{}\n\n", entry.id, status, format!("{:?}", entry.severity), entry.description));
        }

        report
    }
}

impl Default for VulnerabilityTracker {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_audit_report_generation() {
        let mut tracker = VulnerabilityTracker::new();
        tracker.log_finding(TrackingEntry {
            id: "VULN-001".to_string(),
            description: "Missing rate limiter on password reset".to_string(),
            severity: Severity::Medium,
            open: true,
        });

        let report = tracker.generate_audit_report();
        assert!(report.contains("# Security Audit Report"));
        assert!(report.contains("VULN-001"));
        assert!(report.contains("Medium"));
        assert!(report.contains("OPEN"));
    }
}
